<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Booru Image Processor</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      margin-top: 0;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      font-weight: bold;
      margin-bottom: 5px;
    }
    input[type="text"], input[type="number"] {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .folder-select {
      display: flex;
      gap: 10px;
    }
    .folder-select input {
      flex: 1;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .process-btn {
      display: block;
      margin: 20px auto;
      padding: 12px 24px;
      font-size: 16px;
    }
    #log {
      height: 200px;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      margin-top: 20px;
      overflow-y: auto;
      font-family: monospace;
      background-color: #f9f9f9;
    }
    .progress-container {
      margin-top: 20px;
    }
    .progress-bar {
      height: 20px;
      background-color: #4CAF50;
      width: 0%;
      border-radius: 4px;
      transition: width 0.3s;
    }
    .progress-text {
      text-align: center;
      margin-top: 5px;
    }
    .progress-controls {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    #pauseResumeBtn {
      background-color: #2196F3;
    }
    #pauseResumeBtn:hover {
      background-color: #0b7dda;
    }
    #cancelBtn {
      background-color: #f44336;
    }
    #cancelBtn:hover {
      background-color: #d32f2f;
    }
    .error {
      color: #f44336;
      font-weight: bold;
    }
    .success {
      color: #4CAF50;
      font-weight: bold;
    }
    .mode-options {
      margin-top: 5px;
    }
    .mode-options label {
      font-weight: normal;
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    .mode-options input[type="radio"] {
      margin-right: 8px;
    }
    .selected-folders {
      margin-top: 10px;
      max-height: 100px;
      overflow-y: auto;
      font-size: 12px;
    }
    .folder-item {
      background-color: #f0f0f0;
      padding: 4px 8px;
      margin: 2px 0;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
    }
    .remove-folder {
      background: none;
      border: none;
      color: #f44336;
      font-weight: bold;
      cursor: pointer;
      padding: 0 5px;
    }
    .subfolder-option {
      margin-top: 10px;
    }
    .subfolder-option label {
      font-weight: normal;
      display: flex;
      align-items: center;
    }
    .overall-progress {
      margin-top: 10px;
      font-size: 12px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Booru Image Processor</h1>
    
    <div class="form-group">
      <label for="apiEndpoint">API Endpoint:</label>
      <input type="text" id="apiEndpoint" value="http://localhost:5000/evaluate">
    </div>
    
    <div class="form-group">
      <label for="confidenceThreshold">Confidence Threshold:</label>
      <input type="number" id="confidenceThreshold" value="0.5" min="0" max="1" step="0.01">
    </div>
    
    <div class="form-group">
      <label>Input Folders:</label>
      <div class="folder-select">
        <input type="text" id="inputFolder" readonly placeholder="Select folder(s) containing images...">
        <button id="selectFolderBtn">Browse...</button>
      </div>
      <div id="selectedFolders" class="selected-folders">
        <!-- Selected folders will appear here -->
      </div>
      <div class="subfolder-option">
        <label>
          <input type="checkbox" id="includeSubfolders" checked>
          Include subfolders (process images in all subfolders)
        </label>
      </div>
    </div>
    
    <div class="form-group">
      <label>Processing Mode:</label>
      <div class="mode-options">
        <label>
          <input type="radio" name="processMode" value="all" checked>
          Process all images
        </label>
        <label>
          <input type="radio" name="processMode" value="new">
          Process only new images (skip previously processed)
        </label>
        <label>
          <input type="radio" name="processMode" value="missing">
          Reprocess only images with missing JSON files
        </label>
      </div>
    </div>
    
    <button id="processBtn" class="process-btn" disabled>Process Images</button>
    
    <div class="progress-container" style="display:none;">
      <div class="progress-bar"></div>
      <div class="progress-text">0%</div>
      <div class="overall-progress">Preparing...</div>
      <div class="progress-controls">
        <button id="pauseResumeBtn">Pause</button>
        <button id="cancelBtn">Cancel</button>
      </div>
    </div>
    
    <div id="log">Ready to process images...</div>
  </div>
  
  <script>
    const { ipcRenderer } = require('electron');
    const path = require('path');
    
    // Elements
    const apiEndpointInput = document.getElementById('apiEndpoint');
    const confidenceThresholdInput = document.getElementById('confidenceThreshold');
    const inputFolderInput = document.getElementById('inputFolder');
    const selectFolderBtn = document.getElementById('selectFolderBtn');
    const processBtn = document.getElementById('processBtn');
    const progressContainer = document.querySelector('.progress-container');
    const progressBar = document.querySelector('.progress-bar');
    const progressText = document.querySelector('.progress-text');
    const pauseResumeBtn = document.getElementById('pauseResumeBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const logElement = document.getElementById('log');
    
    // State variables
    let isProcessing = false;
    let isPaused = false;
    let selectedFolders = [];
    
    // Get selected process mode
    function getProcessMode() {
      const modeRadios = document.getElementsByName('processMode');
      for (const radio of modeRadios) {
        if (radio.checked) {
          return radio.value;
        }
      }
      return 'all'; // default
    }
    
    // Update the selected folders list in the UI
    function updateSelectedFoldersList() {
      const container = document.getElementById('selectedFolders');
      container.innerHTML = '';
      
      selectedFolders.forEach(folder => {
        const item = document.createElement('div');
        item.className = 'folder-item';
        item.innerHTML = `
          <span>${folder}</span>
          <button class="remove-folder" data-folder="${folder}">×</button>
        `;
        container.appendChild(item);
      });
      
      // Add event listeners to remove buttons
      document.querySelectorAll('.remove-folder').forEach(btn => {
        btn.addEventListener('click', function() {
          const folderToRemove = this.getAttribute('data-folder');
          selectedFolders = selectedFolders.filter(f => f !== folderToRemove);
          
          // Update UI
          if (selectedFolders.length === 0) {
            inputFolderInput.value = '';
            processBtn.disabled = true;
          } else {
            inputFolderInput.value = selectedFolders.length === 1 ? 
              selectedFolders[0] : `${selectedFolders.length} folders selected`;
          }
          
          updateSelectedFoldersList();
        });
      });
    }
    
    // Analyze selected folder and show results
    async function analyzeSelectedFolder(folder) {
      if (!folder) return;
      
      // Show analyzing message
      addLog(`Analyzing folder: ${folder}...`);
      
      // Analyze folder
      try {
        const result = await ipcRenderer.invoke('analyze-folder', folder);
        
        if (result.hasJsonFolder) {
          addLog(`Found existing Json folder in "${path.basename(folder)}" with ${result.jsonCount} JSON files`, 'success');
          
          if (result.logCount > 0) {
            addLog(`Processing log contains ${result.logCount} entries`);
          }
          
          if (result.missingCount > 0) {
            addLog(`Found ${result.missingCount} images with missing JSON files`, 'error');
          }
          
          // Only give recommendations for single folder selection
          if (selectedFolders.length === 1) {
            // Give recommendations
            if (result.jsonCount === 0) {
              addLog(`Recommendation: Use "Process all images" mode`);
            } else if (result.missingCount > 0) {
              addLog(`Recommendation: Use "Reprocess missing JSON files" mode`);
              // Auto-select the missing mode
              document.querySelector('input[name="processMode"][value="missing"]').checked = true;
            } else if (result.jsonCount < result.imageCount) {
              addLog(`Recommendation: Use "Process only new images" mode`);
              // Auto-select the new mode
              document.querySelector('input[name="processMode"][value="new"]').checked = true;
            } else {
              addLog(`All images appear to have JSON files. Use "Process all images" only if you want to regenerate them.`);
            }
          }
        } else {
          addLog(`No existing Json folder found in "${path.basename(folder)}". Will create one when processing.`);
          
          // Only auto-select for single folder
          if (selectedFolders.length === 1) {
            // Auto-select the all mode
            document.querySelector('input[name="processMode"][value="all"]').checked = true;
          }
        }
      } catch (error) {
        addLog(`Error analyzing folder: ${error.message}`, 'error');
      }
    }
    
    // Add event listeners
    selectFolderBtn.addEventListener('click', async () => {
      const folders = await ipcRenderer.invoke('select-folders');
      if (folders && folders.length > 0) {
        // Store and display folders
        selectedFolders = folders;
        
        inputFolderInput.value = selectedFolders.length === 1 ? 
          selectedFolders[0] : `${selectedFolders.length} folders selected`;
        
        updateSelectedFoldersList();
        processBtn.disabled = false;
        
        // Analyze the folders
        addLog(`Selected ${folders.length} folder(s) for processing`);
        
        for (const folder of folders) {
          await analyzeSelectedFolder(folder);
        }
      }
    });
    
    // Check API connection
    async function checkApiConnection() {
      const apiEndpoint = apiEndpointInput.value;
      
      addLog('Checking connection to Booru API...');
      
      try {
        const result = await ipcRenderer.invoke('check-api-connection', apiEndpoint);
        
        if (!result.success) {
          addLog(`Failed to connect to API: ${result.error}`, 'error');
          addLog(`Make sure the Booru Autotagger API is running at ${apiEndpoint}`, 'error');
          
          alert(`Failed to connect to the Booru API at ${apiEndpoint}\n\nError: ${result.error}\n\nMake sure the Docker container is running with:\ndocker run --rm -p 5000:5000 ghcr.io/danbooru/autotagger`);
          return false;
        }
        
        addLog('Successfully connected to Booru API ✓', 'success');
        return true;
      } catch (error) {
        addLog(`Error checking API: ${error.message}`, 'error');
        alert(`Error checking API connection: ${error.message}`);
        return false;
      }
    }
    
    // Toggle pause/resume
    function togglePause() {
      if (!isProcessing) return;
      
      isPaused = !isPaused;
      pauseResumeBtn.textContent = isPaused ? 'Resume' : 'Pause';
      
      ipcRenderer.send('toggle-pause');
      
      if (isPaused) {
        addLog(`Processing paused by user`);
      } else {
        addLog(`Processing resumed by user`);
      }
    }
    
    // Cancel processing
    function cancelProcessing() {
      if (!isProcessing) return;
      
      const confirmCancel = confirm('Are you sure you want to cancel processing?');
      if (confirmCancel) {
        ipcRenderer.send('cancel-processing');
        addLog(`Canceling processing...`, 'error');
      }
    }
    
    // Process button handler
    processBtn.addEventListener('click', async () => {
      if (selectedFolders.length === 0) {
        alert('Please select at least one folder');
        return;
      }
      
      // Check API connection first
      if (!await checkApiConnection()) {
        return;
      }
      
      // Set processing state
      isProcessing = true;
      isPaused = false;
      
      // Disable controls during processing
      processBtn.disabled = true;
      selectFolderBtn.disabled = true;
      
      // Show progress and controls
      progressContainer.style.display = 'block';
      progressBar.style.width = '0%';
      progressText.textContent = 'Preparing...';
      document.querySelector('.overall-progress').textContent = `Preparing to process ${selectedFolders.length} folders...`;
      pauseResumeBtn.textContent = 'Pause';
      
      // Clear log
      logElement.innerHTML = 'Starting processing...<br>';
      
      try {
        const result = await ipcRenderer.invoke('process-images', {
          folders: selectedFolders,
          apiEndpoint: apiEndpointInput.value,
          confidenceThreshold: parseFloat(confidenceThresholdInput.value),
          processMode: getProcessMode(),
          includeSubfolders: document.getElementById('includeSubfolders').checked
        });
        
        if (result.canceled) {
          addLog(`Processing canceled!`, 'error');
        } else {
          addLog(`Processing completed!`, 'success');
        }
        
        addLog(`Total folders: ${result.folderCount}`);
        addLog(`Total images: ${result.total}`);
        addLog(`Processed: ${result.processed}`);
        addLog(`Successfully processed: ${result.success}`);
        addLog(`Failed: ${result.failed}`);
      } catch (error) {
        addLog(`Error: ${error.message}`, 'error');
      } finally {
        // Reset processing state
        isProcessing = false;
        isPaused = false;
        
        // Re-enable controls
        processBtn.disabled = false;
        selectFolderBtn.disabled = false;
      }
    });
    
    // Pause/Resume button handler
    pauseResumeBtn.addEventListener('click', togglePause);
    
    // Cancel button handler
    cancelBtn.addEventListener('click', cancelProcessing);
    
    // Handle pause state changes from main process
    ipcRenderer.on('pause-state-changed', (event, paused) => {
      isPaused = paused;
      pauseResumeBtn.textContent = isPaused ? 'Resume' : 'Pause';
    });
    
    // Handle processing canceled notification
    ipcRenderer.on('processing-canceled', () => {
      isProcessing = false;
    });
    
    // Add log message
    function addLog(message, type = '') {
      const className = type ? ` class="${type}"` : '';
      logElement.innerHTML += `<div${className}>${message}</div>`;
      logElement.scrollTop = logElement.scrollHeight;
    }
    
    // Handle log messages
    ipcRenderer.on('log', (event, message) => {
      addLog(message);
    });
    
    // Handle progress updates
    ipcRenderer.on('progress', (event, data) => {
      const percent = Math.round((data.current / data.total) * 100);
      progressBar.style.width = `${percent}%`;
      progressText.textContent = `${percent}% (${data.current}/${data.total}) - Processing: ${data.file}`;
    });
    
    // Handle folder-level progress
    ipcRenderer.on('progress-folder', (event, data) => {
      const percent = Math.round((data.current / data.total) * 100);
      progressBar.style.width = `${percent}%`;
      progressText.textContent = `${percent}% (${data.current}/${data.total}) - ${data.file}`;
    });
    
    // Handle overall progress
    ipcRenderer.on('progress-overall', (event, data) => {
      const overallEl = document.querySelector('.overall-progress');
      if (overallEl) {
        overallEl.textContent = `Processing folder ${data.current} of ${data.total}: ${path.basename(data.folder)}`;
      }
    });
  </script>
</body>
</html>
